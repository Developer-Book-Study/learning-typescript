# 데이터 타입을 지정하는 이유?
타입을 미리 지정하지 않는 JavaScript는 동적 타입 언어로, 변수의 타입이 실행 시점에 결정되고 변경될 수 있다. 이는 유연성을 제공하지만, 예기치 않은 버그를 발생시킬 수 있다. 
반면 TypeScript는 정적 타입 언어로, 컴파일 시점에 변수의 타입을 검사하여 이러한 문제를 미리 방지한다. 
따라서 TypeScript를 사용하여 데이터 타입을 지정하는 것은 코드의 안정성, 가독성, 유지보수성을 향상시키는 중요한 요소라고 말할 수 있다.





간단한 예시를 들어보자면, JavaScript를 사용할 때는 변수에 어떠한 데이터 타입의 값도 할당 될 수 있었다.

let myName = 'HanSeoYeon';

그런데 누군가가 myName을 실수로 아래와 같이 변경했다고 가정하면

myName = 1;

JavaScript는 이러한 문제를 사전에 막아주지 못한다. 사전에 막아야 할 버그를 이후 프로그램을 사용하다 발견하게 되는 것이다.
사전에 막지 못한 버그들로 인해 이후에 더 큰 문제를 일으킬 수 있기때문에 타입을 지정하여 이와 관련된 버그들을 잡는것은 중요하다.





------------------------------------------------------------------





# 데이터 타입의 종류 
## 기본 데이터 타입
TypeScript의 기본 데이터 타입으로, JavaScript와 거의 동일한 데이터 타입을 지원한다. 


<Number>

숫자 타입으로, 정수와 실수를 포함한다.

<String>

문자열 타입이다.

<Boolean>

참(true)과 거짓(false)을 나타내는 불리언 타입이다.

<Null>

값이 없음을 나타내는 타입이다.

<Undefined>

값이 할당되지 않은 변수의 기본값인 타입이다.





## 객체 타입
<Object>

객체를 나타내는 타입이다.

<Array>

동일한 타입의 요소를 가진 배열을 나타내는 타입이다.

<Tuple>

각 요소가 다른 타입을 가질 수 있는 배열을 나타내는 타입이다.
요소들의 타입이 모두 같을 필요는 없으며, 타입이 Tuple로 정의된 배열은 반드시 동일한 순서와 길이를 따라야 한다.





## 특수 타입
<Enum>
값의 집합에 더 나은 이름을 붙여줄 수 있는 데이터 타입이다. 
예를들어 한국어, 영어, 일본어, 중국어 중 한 언어를 제공하는 제품이 있다고 가정해보자.

const productLanguage: 'kr' | 'en' | 'jp' | 'zh' = 'en'; 


위와 같이 작성을 하게되면 이제 productLanguage 에는 정해진 언어 외에 다른 값을 지정하게되면 에러를 발생하게 된다.
개발을 진행하다 제품마다 지원하는 언어가 다르거나, jp나 zh만으로 이것이 어떤 뜻을 지니고 있는지 파악하기 힘들때가 발생할 수 있다.
이러한 경우에 Enum 타입을 사용할 수 있는데, 이렇게 되면 리터럴의 타입과 값에 각각 이름을 붙여서 코드 가독성을 높일 수 있다.


enum Language {
  korean = 'kr',
  english = 'en',
  japanese = 'jp',
  chinese = 'zh',
}

const productLanguage: Language = Language.english // enum은 객체이므로 이렇게 접근해서 사용할 수 있다.


<Unknown>

타입을 미리 알 수 없는 경우에 사용되는 타입이다.
Any 타입과 거의 유사하지만 컴파일에서 타입 에러를 걸러 낼 수 있다는 차이점이 있다. 

<Any>
모든 타입을 허용하게 하는 타입으로, TypeScript를 무효화 시키는 타입과 동일하여 최대한 사용을 자제하는것이 좋다.

<Void>

주로 아무것도 return 하지않는 함수의 타입을 지정할 때 사용한다.
Any 타입의 반대 타입으로 보통 함수에서 return 값이 없을 때 주로 사용한다.

<Never>

절대 발생하지 않는 값의 타입을 나타낸다. 
예로 함수가 항상 예외를 발생시키거나 무한 루프를 실행할 때 이 타입을 사용할 수 있다.





<Optional Type>

함수의 타입을 지정할 때 특정한 키를 nullable하게 지정할 수 있다. 즉 옵셔널은 undefined를 허용할수도 안할수도 있게 하는것이다.
사용법은 아래와 같이 변수 이름 옆에 ?를 붙이면 된다.

const User : {
  name : string,
  age?: number // ? 는 age : number | undefined 와 동일한 의미

}




<Union Type>

데이터의 타입이 A이거나 B일 수 있다면 이는 Union Type이다.

const User : {
  name : string,
  profile : string | number // profile은 union 타입
}



<Literal Type>

원시 타입 중 어떠한 것이 아닌 내가 지정한 특정 원싯값으로 알려진 타입이다.

const User = 'Han';
-> User에 마우스를 올렸을 때 일반적인 원시타입 대신에 해당 리터럴을 표시한다.
// const User : 'Han';

일반적인 원시타입을 표현하고싶다면 아래와 같이 let으로 작성하면 된다.
let User = 'Han';
// let User : string;


* 유니언 타입에서는 일반적인 원시타입 뿐만아니라 리터럴 타입도 같이 섞어 쓸 수 있다.





------------------------------------------------------------------





# 타입스크립트가 값의 추론을 수행하는 두 가지 핵심 개념
다른 프로그래밍 언어에서는 불가능하지만 타입스크립트에서는 가능한 추론개념


## 유니언(union)
: 값에 허용된 타입을 두 개 이상의 가능한 타입으로 확장하는 것

유니언 타입을 값이 정확히 어떠한 타입인지는 모르지만 두 개 이상의 옵션 중 하나인것을 알고 있을 때 사용한다.
쉽게 말해서 이거아니면 저거 라고 생각하면 된다.



## 내로잉(narrowing)
: 값에 허용된 타입이 하나 이상의 가능한 타입이 되지 않도록 좁히는 것

이전에 유추했던 타입보다 더 구체적인 타입을 좁혀가면서 알아내는 과정이다.
타입을 좁혀가는 데 사용할 수 있는 논리적인 검사를 타입 가드라고 한다.

대표적인 타입 가드 두가지
- 값 할당을 통한 내로잉
- 조건 검사를 통한 내로잉





------------------------------------------------------------------






* TypeScript에서는 함수의 return 타입도 지정해 줄 수 있다. 

함수의 return 타입 지정

함수 선언 단계에서 리턴 타입을 지정해주면 된다. 이렇게 return 타입을 지정해주면 코드 안정성을 높이는 데 많은 도움이 된다.



function add(a,b) : number{

  return a+b

}



* 함수의 축약 선언

축약 가능한 함수라면 아래와 같은 방법으로도 쓸 수 있다.

function add = (a:number, b:number) : number => (a+b)


